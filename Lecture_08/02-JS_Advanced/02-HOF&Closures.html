<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" 
        integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" 
        integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
    <title>02 - Higher Order Functions & Closures</title>
</head>
<body class="container-fluid bg-primary p-2">
    <main class="container-fluid bg-white p-2">
        <h1><u>02 - Higher Order Functions & Closures</u></h1>
        <div class="container">
            <pre class="bg-dark text-white p-3">

//Higher order functions:-
//========================
function fun() {
    console.log('inside fun');
    
    let x = 0;
    
    function innerFun() {
        x++;
        console.log(x);
    }

    return innerFun;

}

let f = fun(); //Output: inside fun

f(); //Output: 1
f(); //Output: 2
f(); //Output: 3
f(); //Output: 4
f(); //Output: 5

console.log('\n\n\n\n');

//Closures:-
//==========
console.log('Closures:\n\n');

var add = (function () {
  var counter = 0;
  return function () {counter += 1; return counter}
})();

console.log(add());
console.log(add());
console.log(add());

// the counter is now 3

//What does this mean?
//The variable add is assigned to the return value of a self-invoking function.
//The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression.
//This way add becomes a function. The "wonderful" part is that it can access the counter in the parent scope.
//This is called a JavaScript closure. It makes it possible for a function to have "private" variables.
//The counter is protected by the scope of the anonymous function, and can only be changed using the add function.

//=>A closure is a function having access to the parent scope, even after the parent function has closed.
            </pre>
        </div>
    </main>
    <footer class="p-3">
        <p class="d-block text-center text-white">Next: <a class="text-white" href="./03-CallBacks&MoreArrayMethods.html">Go to 03 - Callbacks & More Array Methods page</a></p>
    </footer>
    <script>
        //Higher order functions
        function fun() {
            console.log('inside fun');
            
            let x = 0;
            
            function innerFun() {
                x++;
                console.log(x);
            }

            return innerFun;

        }

        let f = fun(); //Output: inside fun

        f(); //Output: 1
        f(); //Output: 2
        f(); //Output: 3
        f(); //Output: 4
        f(); //Output: 5

        
        console.log('\n\n\n\n');

        //Closures:
        console.log('Closures:\n\n');

        var add = (function () {
        var counter = 0;
        return function () {counter += 1; return counter}
        })();

        console.log(add());
        console.log(add());
        console.log(add());
    </script>
</body>
</html>